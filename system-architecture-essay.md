# 系统架构随笔

今年主要参与解决公司多个产品无法规模化交付难题。此由来已久，虽几经努力，但不尽如人意，延续至今，SRE、交付人员成为关键资源瓶颈，严重制约着产品迭代开发、交付部署的效率。究本溯源，公司早期基于 Saas 制定的研发流程、构建的基础设施与私有部署为主的现状不契合，虽勉力维持，终不堪重负，亟待解决，是本次架构设计的核心问题。事关价值交付的关键环节，其严重性不言而喻，并产生了深远的二级影响：敏捷失效。

> 恃剑而生者，最终死于剑锋。恰恰是那些成功因素，在超越特定的时间之后，成为了致命的毒药

不可收敛的固定迭代成本使得经常交付可工作的软件成为泡影，很少有正式的 Hotfix 版本，大家都倾向于一次性开发更多的特性来摊平成本。多个产品因为竞争关键资源而互相“倾轧”，致使发版时间一延再延，难以按时兑现客户承诺，负面反馈接踵而至。几经讨论之下提出了项目制的方案，由项目经理来把控需求范围，锁定迭代资源，保证项目进度，规范开发过程，提高交付质量。

然而，项目制并不是银弹，它是现有效能下的精打细算，期望全面分析种种因素的保守态度不利于产品创新、功能实验，也无法适用小版本的迭代和客户问题的解决。通过做有用的需求来提高效率和质量，其代价除了启动时间长之外(立项)，还延长了功能开发的平均时长，研发效能在现有流程，基础设施的掣肘之下雪上加霜。在现有资源不足的情况下，长期锁定资源并不现实，一些长期项目不得不因此暂停。项目锁定资源的同时，也锁住了大家的主观能动性，降低了一般问题的解决意愿，外部变化的应对更加迟缓。但不论如何，项目制在一定程度上解决资源冲突，清晰核算成本，确保迭代有计划，结果可预期，受到了一定程度上的认可。

正如经过一条坑坑洼洼的路，小心慢行只是权宜之计，无论敏捷还是项目制，都无法回避效能问题。长期只关注结果，必然导致产出和产能失衡，急功近利的后果无人承担，浮华散去，满目疮痍。最后大家只能以非常低效的方式协作，低价值的工作占据了大部分时间，甚至疲于应对层出不穷的问题，那么大家对于工作的意愿，渴望，兴趣就大大降低了。换句话说，由于整个交付链路的混乱和结构性失调，使得组织无法为员工提供良好的工作环境，从而有效发挥其职业特长，那么组织将无法作为一个整体高效的协作以及人才留存。局部优化无法解决系统性的问题，需要以整体视角，系统化的思维，将问题映射到具体的系统，流程，协作方式，才能有所成效，从而获得全局最优解，这个过程需要站在不同的视角去权衡整体利益。

治本的法门在于准确的定义问题；明智的决策在于拥有具足的信息；沟通的效率在于互通情报，建立共同的语言。正所谓“县官不如现管”，如果无法以低成本获得信息优势，自然就没了决策优势，方案的推行很难一帆风顺，是首当其冲的挑战。对于一个极其分散的组织，要想大范围，向众多不同的角色收集信息，达成共识，其困难是不言而喻的：

- 分布式研发体系，产研主要分布在三个不同的城市。
- 涉及的角色很多：后端、算法、运维、产品、测试、运营、技术支持，都是利益相关者。
- 问题的范围很广：涵盖产品的全生命周期，涉及到多个协作流程，影响内部多个系统。
- 需要支持多个产品，每个产品又有十多个可独立开发，独立部署的组件组成。

跨部门的沟通比较难([康威定律](https://zhuanlan.zhihu.com/p/359452953))，这是因为不同部门的人日常语境(上下文)不太一致，基础共识相对低，并且由于分工的角色不同，他们的关注点也截然不同，甚至存在利益冲突。如果没有人从中协调并灵活的平衡，就会出现类似只有市场经济，没有计划经济一样的困境。一个具体的例子是 SRE 认为“开发维护的元数据不可靠，需要一个环境进行验证”，从而导致打包和环境耦合(需要将所有组件部署到单独的环境，才能打产品包)，严重影响发版效率。这种从单一视角出发的设计，很容易有所欠缺，无法满足所有利益相关者的需求。系统设计人员一定要保持开放的心态，有分歧才有收获，有碰撞才有融合(嗯，我是公司的“吵架王”😄，每天大家排队找我掰头)，要想找到差异的根源，就要看到别人眼中的世界，这样视野才会开阔，看待问题才会全面。

即使在后端团队内部，同一技术栈的同学也会产生截然不同的看法，跨技术栈(Java, Golang, C#)的分歧则过之无不及，讨论起来各执己见，甚至互相否定，引发“圣战”([编辑器之战](https://baike.baidu.com/item/%E7%BC%96%E8%BE%91%E5%99%A8%E4%B9%8B%E6%88%98/1472185?fr=ge_ala)；[PHP 是最好的语言](https://baike.baidu.com/item/PHP%E6%98%AF%E6%9C%80%E5%A5%BD%E7%9A%84%E8%AF%AD%E8%A8%80/23731542))。程序员最讨厌两件事：写文档 (因此劝退程序员的一个好方法就是你先写一个文档)和别人不写文档。很难相信一个迭代两年的项目几乎没有任何技术文档，直到这变成了我的亲身所遇。在文档不足的时候，面对面的沟通就变成了很重要的信息获取手段，但由于大家的表达能力参差不齐，就会遇到多种多样的问题，不一而足：

- 逃避问题，放弃沟通，或者 “我不管，我就要”。
- 缺乏抽象思维，讨论一个局部独立的问题也需要画一遍完整的流程图
- 思维很发散，顾左右而言其他，抓不住问题的关键。
- 知其然，不知其所以然，“就应该这样的句式”，沟通容易陷入僵局。
- 走极端的强迫症，比如一切都是配置，无异议的抽象，并且一定要这样，让人很窒息。
- 对方心情不好，容易触了霉头，不妨过段时间再聊。
- 畏难而本能的排斥，需要给对方一段接受的时间再做进一步的沟通。

即使面临诸多挑战，我们也应该尽力获取全面的信息，避免草率得出似是而非的结论。据我观察，开发人员喜欢寻找一种全新的技术、框架、中间件、完全不同的方案来解决问题，他们紧跟时代潮流，努力寻找技术“银弹”，期待彻底改变现状。我非常欣赏这样的追求，但也认识到他们有时会低估技术以外的因素，忽视新事物可能带来的负面影响，缺乏对问题深层原因的分析、归纳、总结，从而提出隔靴搔痒的解决方案，或者走向过度设计的极端。例如在进行配置治理的时候，大家看中的是工具带来的便利性，讨论的焦点是引入哪一个配置中心(Nacos、Apollo、Polaris)，而在综合了以下不同角色，不同视角的信息之后，才发现问题的核心在于配置项及其管理流程的标准化和规范化：

- 交付人员：发货和部署流程里缺少通用客制化参数配置设计，默认配置常常难以满足大部分客户需求。
- 技术支持：配置组织结构混乱，含义模糊不清，虽然额外维护了一套文档，但仍然容易改漏和改错。
- 产品经理：无法为不同客户群体定义不同的版本策略，比如奇数版本只发中文版。
- 开发人员：内部环境的所有配置变更都需要 SRE 的 Review，或者由 SRE 直接修改，过高的沟通成本导致效率低下。
- 测试人员：特定功能组合的测试需要麻烦开发修改配置，而开发需要麻烦运维。
- SRE ：无法聚焦在本职工作的高价值部分，因为维护不同环境的配置就已经占用了他们大部分时间。

事物之间普遍联系，问题很少孤立存在，规模化交付问题也是多种因素共同作用的结果，与产品版本和包定义、生命周期管理、组件化开发、测试验证、发货授权以及部署运维整体过程的不完备和混乱密切相关。为了有效应对如此庞大的问题空间，我们需要采用系统化的分析方法，如鱼骨图，5W2H和MECE，对问题进行分解、重组、归纳、总结和排序，以确定影响问题的关键因素来指导整个建模和设计过程。我们从相对清晰的子问题开始，逐步扩展到与之相关的其他问题，在整个分析过程中，一方面要集思广益，以免遗漏核心要点；另一方面不能凭空猜测，要有充足的细节信息作为判定的依据。这里列出规模化交付问题的部分关键因素以进一步说明：

- 产品没有使用统一的逻辑完整定义，产品信息的获取非常低效。
  - 信创版本，定制化版本的开发、测试、打包、发货、部署、授权脱离主流程。
  - 产品信息有缺失，已有信息散落在各个文档，系统和相关人员的大脑里，大家以非常低效的方式协作。
例如产品信息缺少部署资源要求，交付人员无法指导客户提供符合的机器和环境，导致交付过程一波三折。
  - 产品各个阶段的配置没有标准化，导致产品无法限制特定版本的功能范围(例如对应某些版本只发中文版的产品策略)；产品包的适用性不明，通用定制没有标准化(比如换 Logo 等)，默认配置不满足客户需求。
- Saas 和 私有环境对应不同的部署实现，并且早期基于 Saas 构建的研发流程与私有部署为主的现状不契合。
  - 私有部署在研发流程的末端，问题发现越晚越难解决，部署验证没有合理设计，问题总在客户环境暴露。
  - 组件的开发代码，部署配置，初始化脚本，运行配置，授权项列表以不一致的版本管理，并且无法关联到产品的版本。这是因为 Saas 总是最新版，而私有部署要维护历史版本。此外，这些配置散落在不同的代码仓库，由不同的人维护，协作效率低
- 使用不一致的方式部署不同的组件，以缝缝补补的方式满足新的部署需求，增加了部署系统的复杂性，并且缺乏完备的开发，测试，发版流程(没有产品化)，稳定性比较差。

为了准确把握业务的现在，看到业务发展的未来，我们构建与现实紧密联系的模型，通过选择性的简化和有意的结构化，解决信息超载问题，突出核心内容，从而专注于问题的解决。模型是事情本来面貌的精炼表达，帮助大家集中思维，从而提出尖锐的问题。建模的过程就是不断吸收知识，消化知识，达成共识的过程。很多人抱怨就此构建的模型过于复杂，他们倾向于将复杂现实的粗糙表面磨平成光滑的几条原则或者机制。然而如果一种东西能解释一切，也就等于什么也没解释，现实中更多的是中数系统，要考虑的因素很多，就好比导弹轨迹的计算相当复杂，而不是高中的简单力学题。过于简化的模型往往会丢失关键信息，导致无法做出有效的决策，甚至无法达成真正的共识。设计阶段忽略的分歧和问题最终会在执行阶段暴露出来，这无疑将付出更大的纠错成本。

模型不能建立在抽象不统一的概念上，需要给出定义的依据和原则，并站在不同的视角达成一致的理解。例如最后定义出的产品包和实际的物理包一一对应，而不是定义成一个逻辑包，据此打出多个物理包，这是因为站在产品的角度，每个发出去的物理包都需要被定义，被测试，被管理。这种精确定义的概念很难腐化，例如明确组件元数据是基础设施提供给组件的配置接口，使得组件能够被打包、被部署、被授权，那么基于这个定义，就很容易拒绝掉把应用配置纳入元数据的提议。

> 从外部看，系统有行为，从内部看，系统有结构，系统是行为和结构的统一。    ——--《系统化思维导论》

任何系统必然是一个更大系统的子系统，首先把当前系统当做一个黑盒，通过分析其与环境的关系，来明确系统的职责与边界。其次站在不同角色的视角描述系统的行为，确保其满足所有利益相关者的需求，从而最大化系统的价值。

由于问题本身的复杂性和广泛牵扯面，其必然拥有一个庞大的解空间，我们遵循高内聚低耦合的原则，将整个系统分解成多个相互独立的模块，使得单个模块的复杂度降低到一个可管理的范围内。在划分好层次，明确了边界的基础上，对所有一级模块进行协同设计，核对他们之间调用接口，确保整体设计的一致性和完整性。其中大部分一级模块都是可以独立设计，开发，测试，部署的子系统或组件，由于其良好的内聚性，它们可以随需求的变更而单独演化，并在大部分情况下不影响其他模块。

具体到详细设计，我们使用统一建模语言(UML)来解构要实现的系统。通常包括使用类图来描述系统中对象的类型以及它们之间存在的各种静态关系；使用活动图来描述复杂的业务规则和控制流程；使用时序图描述人和系统以及模块之间的协作关系，而用户与系统，系统内模块之间的交互接口和数据库模型通常可以直接通过代码来定义。从功能方面来说，整个系统的设计和实现要与前面分析得出的业务模型完全绑定，否则其正确性和完整性值得怀疑。不同类型的系统有截然不同的关注点：例如对于交易类型的系统，数据一致性，可追溯性是最优先考虑的事项；而对于私有部署系统，由于其部署的客户规模很大，但单个系统的用户规模很小，所以兼容性，稳定性，可维护性是优先考虑的因素，这就必须在设计中有充分的体现和说明。更具体的说，就是要考虑到阻碍产品规模化交付的关键因素，确保前面提出的核心子问题的解决。

架构的本质是管理复杂度，通过有序化重构，让系统符合当前业务的发展，并可以快速扩展。 有两个问题解决思路贯穿整个设计过程：通过规约降“熵”，该合并的合并，该统一的统一，该规范的规范，避免过度设计而引入额外的复杂度，如奥卡姆剃刀原则 (如无必要，勿增实体)；系统的组织结构和人员的沟通结构相适应，打破各种耦合，从而达到最大的协作效率，如康威定律。

诚然，这篇文章有仓促结尾之嫌，系统设计部分的说明还不够到位，并且我还有很多感兴趣的话题等待探究，比如说面向对象设计，系统设计的高效落地，组织与管理等等。但在这个时间节点，必须做一个阶段性的结束，好在目前这洋洋数千字，已初步对架构做了系统化的描述，额外的部分将作为我的支线任务以继续。

# 参考文档
1. [康威定律(转载)](https://zhuanlan.zhihu.com/p/359452953)
2. [每个架构师都应该研究下康威定律 ](https://www.infoq.cn/article/every-architect-should-study-conway-law)
3. 《领域驱动设计-核心复杂度应对之道》
4. 《有解：高效解决问题的关键七步》
5. 《关键对话：如何高效能沟通》
6. [如何画好一张架构图?(内含知识图谱) - 掘金](https://juejin.cn/post/6844904192394412040)
7. [架构设计4+1视图的作用与关系](https://zhuanlan.zhihu.com/p/112531852)
8. [如何进行系统分析与设计](https://zhuanlan.zhihu.com/p/41501194)
9. [【软件建模】详解架构4+1视图-云社区-华为云](https://bbs.huaweicloud.com/blogs/375202)
10.[架构设计4+1视图的作用与关系](https://zhuanlan.zhihu.com/p/112531852)
11. 《系统化思维导论》
12. [敏捷软件开发宣言](https://agilemanifesto.org/iso/zhchs/manifesto.html)
